Cell 1: Imports and Geometric Primitives
Run this first. It sets up the math libraries and the basic formulas for distance and orientation.

Python

import math

def cross_product(o, a, b):
    """
    Vector Cross Product to determine orientation of ordered triplet (o, a, b).
    Returns:
    > 0 : Counter-Clockwise (Left Turn)
    < 0 : Clockwise (Right Turn)
    = 0 : Collinear
    """
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def get_dist_origin_to_line(p1, p2):
    """
    Calculates the perpendicular distance from Origin (0,0) to the line segment p1-p2.
    """
    x1, y1 = p1
    x2, y2 = p2

    # Standard point-to-line distance formula derived from area
    # Numerator is double the area of triangle formed by (0,0), p1, p2
    numerator = abs(x1 * y2 - x2 * y1)
    
    # Denominator is the length of the segment p1-p2
    denominator = math.sqrt((y1 - y2)**2 + (x1 - x2)**2)
    
    if denominator == 0: return 0 # Points are identical
    return numerator / denominator
Cell 2: Convex Hull Algorithm
Run this second. This defines the Monotone Chain algorithm logic.

Python

def get_convex_hull(points):
    """
    Computes the Convex Hull of a list of 2D points.
    Input: List of tuples [(x, y), ...]
    Output: List of tuples representing hull vertices in CCW order.
    """
    # Sort the points lexicographically (by x, then by y)
    # This is required for Monotone Chain
    points = sorted(points)

    # Build the lower hull 
    lower = []
    for p in points:
        while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)

    # Build the upper hull
    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)

    # Concatenate lower and upper hull
    # The last point of each list is omitted because it is repeated
    return lower[:-1] + upper[:-1]
Cell 3: The Main Solver Function
Run this third. This packages the logic (Origin Trick + Hull + Area Calculation).

Python

def solve_problem(n, r, input_points):
    """
    Solves the empty segment area maximization problem.
    """
    # Create a local copy so we don't modify the original data accidentally
    points = input_points.copy()
    
    # --- LOGIC STEP 1: The Origin Trick ---
    # Add (0,0) to points. If origin is outside the cluster, it becomes a hull vertex.
    points.append((0, 0))
    
    # Remove duplicates
    points = list(set(points))

    # --- LOGIC STEP 2: Get Hull ---
    hull = get_convex_hull(points)

    # Handle degenerate case (e.g., all points lie on a single line)
    # If the hull has <= 2 points, the cut passes through them (and thus origin).
    if len(hull) <= 2:
        return (math.pi * r**2) / 2

    # --- LOGIC STEP 3: Minimize Distance ---
    min_dist = float('inf')
    
    # Close the hull loop to iterate edges easily
    hull.append(hull[0]) 
    
    for i in range(len(hull) - 1):
        p1 = hull[i]
        p2 = hull[i+1]
        dist = get_dist_origin_to_line(p1, p2)
        if dist < min_dist:
            min_dist = dist

    # --- LOGIC STEP 4: Calculate Area ---
    # Area = r^2 * acos(d/r) - d * sqrt(r^2 - d^2)
    
    # Safety check: distance cannot be greater than radius (geometrically impossible here but good for float safety)
    if min_dist >= r:
        return 0.0

    term1 = r**2 * math.acos(min_dist / r)
    term2 = min_dist * math.sqrt(r**2 - min_dist**2)
    
    calculated_area = term1 - term2
    
    # The max area cannot exceed a semi-circle
    max_possible = (math.pi * r**2) / 2
    
    return min(calculated_area, max_possible)
Cell 4: Define Input Data
Run this fourth. This defines the variables N, R, and my_points so the next cell doesn't crash.

Python

# --- INPUT DATA ---
# We define the variables here.
N = 7
R = 15

# List of coordinates from the problem statement
my_points = [
    (9, -4),
    (2, -2),
    (8, 3),
    (0, 4),
    (-6, 10),
    (6, 6),
    (3, 5)
]

print("Data Loaded.")
print(f"Number of points: {len(my_points)}")
print(f"Radius: {R}")
Cell 5: Execute and Print Result
Run this last. It calls the function using the data defined in Cell 4.

Python

# --- EXECUTION ---
# We pass the variables from Cell 4 into the function from Cell 3
result = solve_problem(N, R, my_points)

print("-" * 30)
print(f"Maximum Empty Segment Area: {result:.12f}")
print("-" * 30)

# Verification
expected_output = 353.429173528852
diff = abs(result - expected_output)
print(f"Expected: {expected_output}")
print(f"Precision Error: {diff}")